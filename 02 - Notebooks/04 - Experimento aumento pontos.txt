# ============================================================
# EXPERIMENTO ETTJ PRÉ – INTERPOLAÇÃO E EXTRAPOLAÇÃO
# Dados reais B3 (30/12/2025)
# Métodos:
#   - Spline Cúbico
#   - B-Spline
#   - NSS + BFGS
#   - NSS + Differential Evolution → BFGS
# ============================================================

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import time
import math
from pathlib import Path

from scipy.interpolate import CubicSpline, make_interp_spline
from scipy.optimize import minimize, differential_evolution

# ============================================================
# CONFIGURAÇÕES
# ============================================================

excel_path = "Curva.xlsx"        # <-- ajuste se necessário
sheet_curva = "Plan1"
sheet_pontos = "Planilha1"

out_dir = Path("ettj_outputs")
out_dir.mkdir(exist_ok=True)

np.random.seed(42)

# ============================================================
# FUNÇÕES – NELSON-SIEGEL-SVENSSON
# ============================================================

def nss_zero_rate(t, params):
    b0, b1, b2, b3, tau1, tau2 = params
    t = np.maximum(t, 1e-8)
    x1 = t / tau1
    x2 = t / tau2
    term1 = (1 - np.exp(-x1)) / x1
    term2 = term1 - np.exp(-x1)
    term3 = (1 - np.exp(-x2)) / x2 - np.exp(-x2)
    return b0 + b1*term1 + b2*term2 + b3*term3

def fit_nss_bfgs(x_du, y):
    t = x_du / 252.0
    start = np.array([y[-1], -1, 1, 1, np.log(1), np.log(3)])

    def unpack(z):
        return np.array([z[0], z[1], z[2], z[3], np.exp(z[4]), np.exp(z[5])])

    def obj(z):
        p = unpack(z)
        return np.mean((nss_zero_rate(t, p) - y)**2)

    res = minimize(obj, start, method="BFGS", options={"gtol":1e-10})
    return unpack(res.x)

def fit_nss_de_bfgs(x_du, y):
    t = x_du / 252.0

    def unpack(z):
        return np.array([z[0], z[1], z[2], z[3], np.exp(z[4]), np.exp(z[5])])

    def obj(z):
        return np.mean((nss_zero_rate(t, unpack(z)) - y)**2)

    bounds = [(0,30),(-30,30),(-30,30),(-30,30),(-5,3),(-5,3)]
    de = differential_evolution(obj, bounds=bounds, seed=42)
    res = minimize(obj, de.x, method="BFGS")
    return unpack(res.x)

def predict_nss(params, x_du):
    return nss_zero_rate(x_du / 252.0, params)

# ============================================================
# MÉTRICAS
# ============================================================

def curvature_metric(x, y):
    dy = np.gradient(y, x)
    d2y = np.gradient(dy, x)
    return np.mean(np.abs(d2y))

# ============================================================
# LEITURA DOS DADOS
# ============================================================

curva = pd.read_excel(excel_path, sheet_name=sheet_curva)
curva = curva.rename(columns={"Dias Úteis":"Dias_Uteis", "Preço/Taxa":"Taxa"})
curva = curva.sort_values("Dias_Uteis")

pontos = pd.read_excel(excel_path, sheet_name=sheet_pontos)
pontos = pontos.rename(columns={"Dias Uteis":"Dias_Uteis"})

x_real = curva["Dias_Uteis"].values
y_real = curva["Taxa"].values

def taxa_real(du):
    return np.interp(du, x_real, y_real)

pos_to_du = dict(zip(pontos["Posição"], pontos["Dias_Uteis"]))

# ============================================================
# DEFINIÇÃO DOS CENÁRIOS DE PONTOS
# ============================================================

base_5 = [1, 9, 18, 27, 36]
all_pos = sorted(pos_to_du.keys())
remaining = [p for p in all_pos if p not in base_5]
np.random.shuffle(remaining)

sets = {}
current = base_5.copy()
for s in [5, 10, 15, 20, 25, len(all_pos)]:
    while len(current) < s:
        current.append(remaining.pop())
    sets[s] = sorted(current)

# ============================================================
# BENCHMARK (TODOS OS 279 PONTOS)
# ============================================================

bench = {
    "Spline": CubicSpline(x_real, y_real, bc_type="natural", extrapolate=True),
    "BSpline": make_interp_spline(x_real, y_real, k=3),
    "BFGS": fit_nss_bfgs(x_real, y_real),
    "DE+BFGS": fit_nss_de_bfgs(x_real, y_real)
}

x_ext = np.array([x_real.max()+252, x_real.max()+504, x_real.max()+1260])
bench_ext = {
    k: (v(x_ext) if callable(v) else predict_nss(v, x_ext))
    for k,v in bench.items()
}

# ============================================================
# LOOP PRINCIPAL DO EXPERIMENTO
# ============================================================

rows_interp = []
rows_extrap = []

for n, pos_list in sets.items():
    x_sel = np.array([pos_to_du[p] for p in pos_list])
    y_sel = taxa_real(x_sel)

    xmin, xmax = x_sel.min(), x_sel.max()
    mask = (x_real >= xmin) & (x_real <= xmax)
    x_cmp, y_cmp = x_real[mask], y_real[mask]

    models = {}

    # ---------------- INTERPOLAÇÃO ----------------
    for name in ["Spline","BSpline","BFGS","DE+BFGS"]:
        t0 = time.time()

        if name == "Spline":
            model = CubicSpline(x_sel, y_sel, bc_type="natural", extrapolate=True)
            y_hat = model(x_cmp)
        elif name == "BSpline":
            model = make_interp_spline(x_sel, y_sel, k=min(3,len(x_sel)-1))
            y_hat = model(x_cmp)
        elif name == "BFGS":
            model = fit_nss_bfgs(x_sel, y_sel)
            y_hat = predict_nss(model, x_cmp)
        else:
            model = fit_nss_de_bfgs(x_sel, y_sel)
            y_hat = predict_nss(model, x_cmp)

        dt = time.time() - t0
        mse = np.mean((y_hat - y_cmp)**2)
        curv = curvature_metric(x_cmp, y_hat)

        rows_interp.append([n, name, mse, curv, dt])
        models[name] = model

        # -------- EXTRAPOLAÇÃO --------
        y_ext = model(x_ext) if callable(model) else predict_nss(model, x_ext)
        mse_ext = np.mean((y_ext - bench_ext[name])**2)
        rows_extrap.append([n, name, mse_ext, *y_ext])

    # ---------------- PLOT ----------------
    x_plot = np.linspace(xmin, xmax, 800)
    plt.figure(figsize=(10,5))
    plt.plot(x_real, y_real, label="Curva B3", lw=2)

    for name, model in models.items():
        y_plot = model(x_plot) if callable(model) else predict_nss(model, x_plot)
        plt.plot(x_plot, y_plot, label=name)

    plt.scatter(x_sel, y_sel, c="black", zorder=5)
    plt.title(f"Interpolação – {n} pontos")
    plt.xlabel("Dias úteis")
    plt.ylabel("Taxa")
    plt.legend()
    plt.tight_layout()
    plt.savefig(out_dir / f"interp_{n}.png", dpi=150)
    plt.close()

# ============================================================
# PLOT EXTRAPOLAÇÃO
# ============================================================

x_plot = np.linspace(x_real.min(), x_ext.max(), 1200)
plt.figure(figsize=(10,5))
plt.plot(x_real, y_real, label="Curva B3", lw=2)

for name, model in bench.items():
    y_plot = model(x_plot) if callable(model) else predict_nss(model, x_plot)
    plt.plot(x_plot, y_plot, label=name)
    plt.scatter(x_ext, bench_ext[name])

for x in x_ext:
    plt.axvline(x, ls="--", alpha=0.6)

plt.title("Extrapolação – +1y, +2y, +5y")
plt.xlabel("Dias úteis")
plt.ylabel("Taxa")
plt.legend()
plt.tight_layout()
plt.savefig(out_dir / "extrapolacao.png", dpi=150)
plt.close()

# ============================================================
# TABELAS FINAIS
# ============================================================

df_interp = pd.DataFrame(
    rows_interp,
    columns=["N_Pontos","Metodo","MSE_Interp","Curvatura","Tempo_s"]
)

df_extrap = pd.DataFrame(
    rows_extrap,
    columns=["N_Pontos","Metodo","MSE_Extrap","Taxa_1Y","Taxa_2Y","Taxa_5Y"]
)

with pd.ExcelWriter(out_dir / "resultados_metricas.xlsx") as writer:
    df_interp.to_excel(writer, sheet_name="Interpolacao", index=False)
    df_extrap.to_excel(writer, sheet_name="Extrapolacao", index=False)

print("Experimento finalizado com sucesso.")
print("Arquivos gerados em:", out_dir.resolve())